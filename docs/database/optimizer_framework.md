


## 概述

在数据库系统中，优化器的作用是为输入的查询语句寻找一个代价最低的，正确的执行计划。但是这是一个NP-hard问题。没有任何一个优化器能够找到一个真正最优的计划，他们采用一些估算的方法猜测计划的执行代价，并且使用一些启发式规则限制搜索的空间。

SQL语句被解析器解析并绑定符号后形成一个逻辑的关系代数表达式。接下来，优化器将这个逻辑的关系代数表达式转换成物理的关系代数表达式，也就是执行计划。这种转换是等价的。所谓等价，是指在他们将产生相同的正确结果。

OLTP的优化器实现相对简单。数据表上通常建有索引，多表之间的连接条件通常在主键和外键之间，所以OLTP优化器可以通过一些简单的启发式规则实现。但是在OLAP数据库中，优化器就要复杂得多。

## 优化器的搜索策略

大体上说，优化器的搜索策略有五种实现方式，分别是：

- 启发式
- 启发式 + 基于代价的Join顺序选择
- 随机算法
- 分层搜索
- 整体搜索

### 启发式

早期的INGRES和Oracle采用的是启发式搜索策略。启发式搜索策略将选择和投影尽量pushdown，将选择利率低的条件先做，Join顺序的选择也是基于选择率的。

启发式的搜索策略首先对语句进行分解，将语句拆分成单表的查询。遇到Join语句时，将Join中的某一个表的所有行取出，获取其Join条件中的列，并在原语句中转换成常量，也就将Join语句换成了带条件的单表查询。往往一条语句要被拆分成数十条语句进行处理。

优点：

- 实现和调试较为简单
- 简单语句运行较快

缺点：

- 难于处理具有复杂的依赖关系的语句

### 启发式 + 基于代价的Join顺序选择

System R和早期的DB2采用这种方法。这是一种最早期的基于代价的优化器实现方式。整体来说是一个Bottom-up的流程。

启发式 + 基于代价的Join顺序选择策略是面向Block的，针对每一个Block生成相应的逻辑操作符，再转换成物理操作符。它首先使用一些静态的规则进行初始的优化，然后使用动态规划算法对Join顺序进行选择。在生成Join顺序时，采用的是Left-deep树，这可以缩小搜索空间。

在生成路径时，首先，为每一个表生成其访问路径。其次，枚举所有可能的Join顺序方案。最后，挑选代价最低的Join顺序。

优点：

- 受控的搜索空间中可以找到一个相对不错的执行计划

缺点：

- Left-deep树并不一定最优
- 在代价模型中难于考虑一些物理属性，比如数据的排序

### 随机算法

Postgres的遗传算法属于这个分类。首先采用启发式方法生成一个执行计划，然后执行计划在解决方案空间中进行随机的变换，直到其代价满足一个阈值或搜索的时间超过预定的时间。

优点：

- 在解决方案空间中随机的变换可以避免局部最优解
- 无需大量内存保存子执行计划

缺点：

- DBA和用户无法判断为什么DBMS选择这样的执行计划
- 需要额外的工作以确保执行计划的稳定
- 需要实现正确的的转换规则

## 一些High Level的点
