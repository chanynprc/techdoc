## 查询优化框架

### 优化器概述

在数据库系统中，优化器的作用是为输入的查询语句寻找一个代价最低的，正确的执行计划。但是这是一个NP-hard问题。没有任何一个优化器能够找到一个真正最优的计划，他们采用一些估算的方法猜测计划的执行代价，并且使用一些启发式规则限制搜索的空间。

SQL语句被解析器解析并绑定符号后形成一个逻辑的关系代数表达式。接下来，优化器将这个逻辑的关系代数表达式转换成物理的关系代数表达式，也就是执行计划。这种转换是等价的。所谓等价，是指在他们将产生相同的正确结果。

OLTP的优化器实现相对简单。数据表上通常建有索引，多表之间的连接条件通常在主键和外键之间，所以OLTP优化器可以通过一些简单的启发式规则实现。但是在OLAP数据库中，优化器就要复杂得多。

优化器中比较核心的问题包括：搜索策略、代价模型和行数估算。本文的重点放在搜索策略上。

### 搜索策略分类

大体上说，优化器的搜索策略有五种实现方式，分别是：

- 启发式
- 启发式 + 基于代价的Join顺序选择
- 随机算法
- 分层搜索
- 整体搜索

#### 启发式

早期的INGRES和Oracle采用的是启发式搜索策略。启发式搜索策略将选择和投影尽量pushdown，先扫描输出行数少的基表，Join顺序的选择也是先做输出行数少的Join。

启发式的搜索策略首先对语句进行分解，将语句拆分成单表的查询。遇到Join语句时，将Join中的某一个表的所有行取出，获取其Join条件中的列，并在原语句中转换成常量，也就将Join语句换成了带条件的单表查询。往往一条语句要被拆分成很多语句进行处理。

优点：

- 实现和调试较为简单
- 简单语句运行较快

缺点：

- 难于处理具有复杂的依赖关系的语句

#### 启发式 + 基于代价的Join顺序选择

System R、早期的DB2，以及大多数开源数据库采用这种方法。这是最早的基于代价的优化器实现方式，也是最经典的方式。整体来说是一个Bottom-up的流程。启发式 + 基于代价的Join顺序选择策略是面向Block的，针对每一个Block做各种优化和执行计划生成。

它主要分为两个阶段：

1. 使用一些规则进行初始的优化
2. 使用动态规划算法对Join顺序进行选择

在使用动态规划算法生成路径时，首先，为每一个表生成其访问路径（比如顺序扫描或者索引扫描）。其次，枚举所有可能的Join顺序方案。最后，挑选代价最低的Join顺序，输出执行计划。

System R在生成Join顺序时，采用的是Left-deep树，这可以缩小搜索空间。PostgreSQL并不局限于Left-deep树，它采用了更大的搜索树空间。

优点：

- 受控的搜索空间中可以找到一个相对不错的执行计划

缺点：

- Left-deep树并不一定最优
- 容易产生局部最优解，而局部最优并不一定使最终的执行计划最优
- 在代价模型中难于考虑一些物理属性，比如数据的排序

#### 随机算法

PostgreSQL的遗传算法属于这个分类。首先采用启发式方法生成一个执行计划，然后执行计划在解决方案空间中进行随机的变换，直到其代价满足一个阈值或搜索的时间超过预定的时间。

优点：

- 在解决方案空间中随机的变换可以避免局部最优解
- 无需大量内存保存子执行计划

缺点：

- DBA和用户无法判断为什么DBMS选择这样的执行计划
- 需要额外的工作以确保执行计划的稳定
- 需要实现正确的的转换规则

#### 分层搜索

DB2和Oracle采用这种策略，也称为StarBurst框架。首先使用查询重写技术对逻辑表达式进行重写，这一步是不考虑代价的。然后然后进行基于代价将逻辑表达式转换为物理执行计划。

#### 整体搜索

SQL Server和Orca采用这种搜索策略，也称为Volcano或Cascades框架。它将逻辑表达式到逻辑表达式的转换，以及逻辑表达式到物理执行计划的转换整合在了一起。通过一系列的转换规则完成查询语句的优化。它的搜索流程是Top-down的。它是目标驱动的，根据最终的目标一步一步生成最终的执行计划。

在变换的过程中，如果生成的计划偏离了目标（比如不满足排序要求），将对该分支进行剪枝。此外，如果发现某分支的代价大于已生成的分支，也会对这个分支进行剪枝。这样就达到了缩小搜索空间的目的。

优点：

- 具有更好的扩展性
- 通过声明的方式添加转换规则
- 通过一种数据结构，减少冗余的计算

缺点：

- 需要在优化中将所有的等价类展开，并生成所有的物理算子，所需内存空间较大
- 框架实现难度大

### PostgreSQL优化器

PostgreSQL优化器使用了一整套较为模式化的工作流进行查询优化，属于启发式 + 基于代价的Join顺序选择的搜索策略。首先使用启发式的方法对查询进行重写（逻辑优化），然后使用基于代价的方法自底向上选择最优的Join顺序（物理优化），最后排序和聚集等操作被作为添加项添加到执行计划上。它的优化过程也是面向Block的，子查询的优化需要重复上述过程。

#### 逻辑优化

PostgreSQL解析器将查询语句解析成一种内部的数据结构，称为解析树，也就是一个逻辑的关系代数表达式。标记了每个查询块的目标列、范围表、条件、聚集和排序信息等。在逻辑优化阶段，优化器将对这个逻辑的关系代数表达式进行等价代换，这种代换是基于规则的，我们称之为查询重写。查询重写包括但不限于条件下推、子查询提升等。这些重写规则被逐一应用到逻辑的关系代数表达式上，最终形成一个等价的更优的关系代数表达式。

在PostgreSQL中，逻辑优化是基于规则的，只要关系代数表达式满足重写条件，优化器将对其进行相关的查询重写。随着重写规则的丰富，有些重写规则并不一定在所有情况下使关系代数表达式更优，就需要一些参数去控制这些重写规则的开关。在有些优化器中，也将重写规则纳入到基于代价的部分，根据实际代价去判断是否应用某些重写规则。

#### 物理优化

PostgreSQL优化器物理优化有两种方式，一个基于动态规划的算法，另一个是基于遗传算法。当待连接的表数超过一定数量时会使用遗传算法，当表的数量不超过这个预定值时会使用动态规划算法。这里我们主要看动态规划算法。

PostgreSQL会首先将解析树转换成另外一种内部数据结构，叫做路径。会Bottom-up地生成整个查询块的路径。

首先会生成基表扫描的路径。在生基表描路径的时候，为基表挑选一种最佳的扫描方式。一般而言，基表扫描有顺序扫描和索引扫描的方式。优化器会计算顺序扫描的代价，以及利用表上每一个索引扫描的代价。从中挑选一个代价最小的方式作为该表的扫描路径。从经验上看，选择率较高的查询适用于选择顺序扫描，选择率较低且在过滤条件上建有索引的情况更适用于选择索引扫描。

如果查询中有Join，则会使用动态规划算法生成Join的路径。先生成两个表Join的路径，然后是三个表、四个表……直到生成所有表Join的路径。生成两个表Join路径时，会用到基表扫描的路径，同时考虑了表的Join顺序和Join方式（Hash Join、Sort Merge Join或Nest Loop Join），然后保留代价最优的路径供后续路径生成使用。在生成三个表Join路径时，会使用到基表扫描路径和两个表Join路径，层层向上，生成更高层Join路径时不需要重复计算底层路径的代价，但需要枚举所有底层路径。

在早期的PostgreSQL中，物理优化仅考虑Join顺序和Join路径生成，在最新版本中，将聚集操作也纳入到物理优化之中，会生成聚集路径。

生成完路径后，优化器根据路径生成相应的物理执行计划，一些与执行相关的信息被加入到执行计划中。一些对目标列的处理、窗口函数、聚集操作、排序操作等也被添加到物理执行计划上，最后对物理执行计划进行综合整理。

### Cascades框架

Cascades框架是Volcano框架的面相对象实现，也解决了一些Volcano框架的短板，是一种Top-down的转换型的框架。它主要有两个核心组件组成：MEMO数据结构和优化任务。MEMO数据结构用来保存已搜索的计划空间数据，优化任务用来引导搜索策略。

#### MEMO数据结构

MEMO数据结构由两部分组成：Group和GroupExpression。Group表示所有等价的算子的集合。GroupExpression是Group中的一个算子，可能是逻辑算子，也可能是物理算子。

Group中的GroupExpression之间是相互串联在一起的。GroupExpression的孩子是其他Group中的GroupExpression，比如一个表示两个表Join的GroupExpression的左子树和右子树指向其他表示基表扫描Group中满足条件且代价最小的GroupExpression。

GroupExpression带有一些属性表示算子的状态。属性分为两种，逻辑属性和物理属性。逻辑属性被一个Group中的所有GroupExpression共享，比如该Group操作的物理表、输出列、输出行数等信息。而物理属性属于某一个GroupExpression，比如该GroupExpression的排序情况、代价大小等。

#### 优化任务

在优化一条查询语句时，Cascades框架首先在MEMO数据结构中建立表示一系列逻辑算子的Group，比如A表和B表Join，会生成3个Group，分别是Group(A Join B)、Group(Scan A)、Group(Scan B)。然后发起一个针对根算子的优化任务，这个优化任务会为其子算子触发一系列的子优化任务，层层迭代最终生成一个最优的执行计划。最后将这个执行计划交由执行器执行。

优化任务有五个主要模块组成：

- OptimizeGroup
- ExploreGroup
- ExploreGroupExpression
- ApplyRule
- OptimizeInput

OptimizeGroup是优化任务的主入口。它的输入有三个：（1）G：一个待优化的Group，初始状态就是根算子所在的Group，（2）RP：输出数据的物理属性，比如排序情况等，（3）UB：执行代价的参考点。OptimizeGroup的输出是最优的执行计划。也就是说，OptimizeGroup的目的是输出Group G的满足数据物理属性RP并且执行代价低于执行代价参考点UB的最优的执行计划。在OptimizeGroup被调起后，首先会到一个称为WinnerCircle的结构中去寻找已生成的G中满足RP计划，WinnerCircle(G, RP)。如果找到了这样的计划，并且它的代价小于UB，则OptimizeGroup直接返回这个计划。如果找到了这样的计划，但是它的代价大于UB，则返回NULL，表示无法构造满足条件的计划。如果在WinnerCircle中没有找到这样的计划，则调用ExploreGroup对该Group进行计划生成处理。

ExploreGroup的任务很简单，就是调用ExploreGroupExpression对Group中的每一个GroupExpression进行处理，将发现的最优计划记录到WinnerCircle的结构中，并返回该最优计划。

ExploreGroupExpression负责对GroupExpression进行处理，也就是应用所有可能的ApplyRule对其进行转换，生成等价的GroupExpression。ExploreGroupExpression会使用一种Bitmap结构来记录可以应用哪些规则进行转换，不可以应用哪些规则进行转换，避免生成冗余的GroupExpression。

ApplyRule是优化任务中较为核心的模块。如果GroupExpression满足相关条件和特征则对其应用相关的变换规则进行转换。变换规则有两大类：（1）Exploration rules：将逻辑表达式转换成等价的逻辑表达式，比如将A Join B转换为B Join A，（2）Implementation rules：将逻辑表达式转换成物理表达式，比如将A Join B转换为A Hash Join B。在变换的过程中可能会产生新的逻辑表达式（Logical GroupExpression），也可能会产生新的物理表达式（Physical GroupExpression），甚至产生新的Group。新产生的GroupExpression会触发后续的变换。Logical GroupExpression会触发新的ExploreGroupExpression，Physical GroupExpression会触发其输入算子的OptimizeInput，并且会计算包含其输入算子在内的整体代价。

OptimizeInput为有输入要求的Physical GroupExpression服务，根据输入要求确定Group G、RP和UB，并调用OptimizeGroup进行递归处理。在OptimizeInput中，也会考虑代价的因素，根据需要进行剪枝。

按照上述过程层层迭代，我们最终会在根Group得到一个最优执行计划。因为在搜索的过程中进行了剪枝，其搜索空间会相对小一些。对于根算子所在Group而言，选择一个合适的UB决定了优化过程中剪枝的力度，并直接影响优化效率，优化器可以通过一些经验规则，快速选定一个UB，将搜索空间限定在包含最优解的一个很小范围内。

### PostgreSQL优化器 VS Orca

PostgreSQL优化器的流程是Bottom-up的，首先生成基表的访问路径，再层层向上升成最终的执行计划，每一层都要生成所有的子计划。在层层向上的过程中，挑选每一步的局部最优解，后一步利用前面步骤的结果进行物理算子和Join顺序的选择。在生成每一层最优解的过程中，并不考虑最终需要的物理属性。最终生成的执行计划并不一定是全局最优的，因为全局最优的计划的分支不一定是局部最优的。

Orca使用的是Cascades框架，是Top-down的，根据目标输出，向下生成相应的执行计划。它的整个过程也加入动态规划的思想，尽可能复用已经生产的子计划。在计划生成之中，如果某个分支计划的代价已经明显大于已经存在的计划，则会对该分支进行剪枝。它每一步的计划生成都是以目标结果为导向的，所以更容易找到全局最优的计划，搜索空间也会相对小一些。

PostgreSQL优化器遵循一整套较为紧耦合的工作流，它的流程顺序不能够被改变，所以对其优化器的更改和扩展比较困难。在实际开发中我们经常发现，对某一个小点的更改会影响流程前后一系列的逻辑，而这样的相互影响有时候是致命的。受困于紧耦合的工作流，在开发新特性时，开发者不得不在梳理前后逻辑和测试模块间交互上花大功夫，有时候是事倍功半的。

Orca的Cascades框架将搜索策略和转换规则分离开来，甚至代价模型也是分离的。开发者可以通过实现一些声明规则达到优化目的，实现这些规则时开发者并不需要对搜索策略进行修改，这样在开发的过程中只需关注转换规则实现，而不用在上下文逻辑和模块间交互上花太多的功夫。但是，Cascades框架本身的实现是很难的。

PostgreSQL优化器的Join顺序选择采用了动态规划的算法，但是集合和聚集操作的优化是独立于动态规划算法之外的，无法融入其中。Orca中一切都是变换，变换就是一切，只有想不到，没有做不到。

PostgreSQL优化器代码是集成在内核之中的，是PostgreSQL专用的。而Orca被从数据库内核中独立出来，作为一个独立的核心组件可供多种数据库使用，在Pivital的产品中就包括Greenplum和HAWQ。

### 一些High Level的点

#### 优化粒度

单语句优化：单语句优化是指每次只优化一条查询语句。它的搜索空间被限制在单个语句之中，实现起来较为简单。但是它不能复用其他语句优化过程中的中间结果。此外优化器还需要考虑其他并发执行的语句，避免出现资源的抢占。

多语句优化：多语句优化是指同时对多个并发执行的语句进行优化。如果语句相似则可以复用优化数据，甚至可以在执行时复用查询的中间结果，对资源的利用会更加的合理。但是搜索空间会比较大。

#### 优化时间点

静态优化：静态优化是指在执行前生成完整的执行计划。这种优化方式实现起来较为简单，也是大多数数据库优化器采用的方式。但是优化器对计算资源的估计是基于优化的时间点的，并不是基于执行时的真实数据。此外，静态优化严重依赖于行数估算和代价估算，如果行数估算或代价模型有问题，将导致查询执行缓慢，且无补救措施。

动态优化：动态优化是指在执行的时候根据执行情况动态生成执行计划。在执行时能够获得执行中间结果的具体行数，而不用依赖于行数的估算，更容易生成更优的执行计划。但是这种方式并不好实现，并且调试起来也相当复杂。

混合优化：混合优化是指在执行前先生成一个静态的执行计划。在执行过程中，如果发现估算的行数和真实行数相差太大，则重新进行计划的生成。

#### 计划稳定性

优化器架构、行数估算方式以及代价模型的调整，会导致计划不稳定，所以需要一些手段去保证计划的稳定性。

Hints：Hints可以让DBA通过一种手工指定的方式制定全部或部分执行计划。这种方式对DBA水平要求较高，要求能够发现较好的执行计划并且通过Hints方式进行指定，工作量较大。

版本控制：在优化器进行升级时，保留版本控制设置接口，如果用户对新版本优化器生成的执行计划不满意，可以通过版本控制接口生成老版本的执行计划。

兼容计划缓存：可以在保证正确性和兼容性的前提下，对原执行计划进行缓存，并用于语句的执行。

#### 含参语句的优化

存储过程或者函数中的某些语句是含有参数的，在生成执行计划时优化器并不知道这些参数的值是多少，所以很难给出一个准确的执行计划。

重新生成执行计划：在参数确定时对该语句的执行计划进行重新的生成。

多版本计划：为不同的输入参数生成多个版本的执行计划，并存储。

平均计划：为参数确定一个平均值，并使用该平均值生成计划。

### 引用

[1] Nicolas Bruno and Rimma V. Nehme. 2008. Configuration-parametric query optimization for physical design tuning. In Proceedings of the 2008 ACM SIGMOD international conference on Management of data (SIGMOD '08). ACM, New York, NY, USA, 941-952.

[2] Goetz Graefe. The Cascades framework for query optimization. Data Engineering Bulletin, 18(3), 1995.

[3] Mohamed A. Soliman, Lyublena Antova, Venkatesh Raghavan, Amr El-Helw, Zhongxian Gu, Entong Shen, George C. Caragea, Carlos Garcia-Alvarado, Foyzur Rahman, Michalis Petropoulos, Florian Waas, Sivaramakrishnan Narayanan, Konstantinos Krikellas, and Rhonda Baldwin. 2014. Orca: a modular query optimizer architecture for big data. In Proceedings of the 2014 ACM SIGMOD International Conference on Management of Data (SIGMOD '14). ACM, New York, NY, USA, 337-348.

[4] Andy Pavlo. 2017. Database Systems. Carnegie Mellon University, 15-721.
