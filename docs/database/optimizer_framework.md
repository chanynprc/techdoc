

### 概述

在数据库系统中，优化器的作用是为输入的查询语句寻找一个代价最低的，正确的执行计划。但是这是一个NP-hard问题。没有任何一个优化器能够找到一个真正最优的计划，他们采用一些估算的方法猜测计划的执行代价，并且使用一些启发式规则限制搜索的空间。

SQL语句被解析器解析并绑定符号后形成一个逻辑的关系代数表达式。接下来，优化器将这个逻辑的关系代数表达式转换成物理的关系代数表达式，也就是执行计划。这种转换是等价的。所谓等价，是指在他们将产生相同的正确结果。

OLTP的优化器实现相对简单。数据表上通常建有索引，多表之间的连接条件通常在主键和外键之间，所以OLTP优化器可以通过一些简单的启发式规则实现。但是在OLAP数据库中，优化器就要复杂得多。

### 优化器的搜索策略

大体上说，优化器的搜索策略有五种实现方式，分别是：

- 启发式
- 启发式 + 基于代价的Join顺序选择
- 随机算法
- 分层搜索
- 整体搜索

#### 启发式

早期的INGRES和Oracle采用的是启发式搜索策略。启发式搜索策略将选择和投影尽量pushdown，将选择利率低的条件先做，Join顺序的选择也是基于选择率的。

启发式的搜索策略首先对语句进行分解，将语句拆分成单表的查询。遇到Join语句时，将Join中的某一个表的所有行取出，获取其Join条件中的列，并在原语句中转换成常量，也就将Join语句换成了带条件的单表查询。往往一条语句要被拆分成数十条语句进行处理。

优点：

- 实现和调试较为简单
- 简单语句运行较快

缺点：

- 难于处理具有复杂的依赖关系的语句

#### 启发式 + 基于代价的Join顺序选择

System R、早期的DB2和大多数开源数据库采用这种方法。这是最早的基于代价的优化器实现方式。整体来说是一个Bottom-up的流程。启发式 + 基于代价的Join顺序选择策略是面向Block的，针对每一个Block做各种优化和执行计划生成。

它主要分为两个阶段：

1. 使用一些规则进行初始的优化
2. 使用动态规划算法对Join顺序进行选择

在使用动态规划算法生成路径时，首先，为每一个表生成其访问路径（比如顺序扫描或者索引扫描）。其次，枚举所有可能的Join顺序方案。最后，挑选代价最低的Join顺序，输出执行计划。

System R在生成Join顺序时，采用的是Left-deep树，这可以缩小搜索空间。PostgreSQL并不局限于Left-deep树，它采用了更大的搜索树空间。

优点：

- 受控的搜索空间中可以找到一个相对不错的执行计划

缺点：

- Left-deep树并不一定最优
- 局部最优并不一定使最终的执行计划最优
- 在代价模型中难于考虑一些物理属性，比如数据的排序

#### 随机算法

PostgreSQL的遗传算法属于这个分类。首先采用启发式方法生成一个执行计划，然后执行计划在解决方案空间中进行随机的变换，直到其代价满足一个阈值或搜索的时间超过预定的时间。

优点：

- 在解决方案空间中随机的变换可以避免局部最优解
- 无需大量内存保存子执行计划

缺点：

- DBA和用户无法判断为什么DBMS选择这样的执行计划
- 需要额外的工作以确保执行计划的稳定
- 需要实现正确的的转换规则

#### 分层搜索

DB2和Oracle采用这种策略，也称为StarBurst框架。首先使用查询重写技术对逻辑表达式进行重写，这一步是不考虑代价的。然后然后进行基于代价将逻辑表达式转换为物理执行计划。

#### 整体搜索

SQL Server和Greenplum Orca采用这种策略。也称为Volcano和Cascades框架。他将逻辑表达式到逻辑表达式的转换以及逻辑表达式到物理执行计划的转换整合在了一起。通过一系列的转换规则完成查询语句的优化。它的搜索流程是Top-down的。它是目标驱动的，根据最终的目标一步一步生成最终的执行计划。

在变换的过程中，如果生成的计划偏离了目标（比如不满足排序要求），将对该分支进行剪枝。此外，如果发现某分支的代价大于已生成的分支，也会对这个分支进行剪枝。

优点：

- 具有更好的扩展性
- 通过声明的方式添加转换规则
- 通过一种数据结构，减少冗余的计算

缺点：

- 需要在优化前将所有的等价类展开，并生成所有的物理算子

### PostgreSQL优化器

PostgreSQL优化器使用了一整套较为模式化的工作流进行查询优化。首先使用启发式的方法对查询进行重写（逻辑优化），然后使用基于代价的方法自底向上选择最优的Join顺序（物理优化），最后排序和聚集等操作被作为添加项添加到执行计划上。它的优化过程也是面向Block的，子查询的优化需要重复上述过程。

#### 逻辑优化

PostgreSQL解析器将查询语句解析成一种内部的数据结构，称为解析树，也就是一个逻辑的关系代数表达式。标记了每个查询块的目标列、范围表、条件、聚集和排序信息等。在逻辑优化阶段，优化器将对这个逻辑的关系代数表达式进行等价代换，这种代换是基于规则的。代换包括但不限于条件下推、子查询提升等。这些代换被逐一应用到逻辑的关系代数表达式上，最终形成一个等价的关系代数表达式。

在PostgreSQL中，逻辑优化是基于规则的，只要关系代数表达式满足变换条件，优化器将对其进行相关逻辑优化。随着重写规则的丰富，有些重写规则并不一定在所有情况下使关系代数表达式更优，所以在有些优化器中，也将重写规则纳入到基于代价的部分，根据实际代价去判断是否应用某些重写规则。

#### 物理优化

PostgreSQL优化器物理优化有两种方式，一个基于动态规划的算法，另一个是基于遗传算法。当待连接的表数超过一定数量时会使用遗传算法，当表的数量不超过这个预定值时会使用动态规划算法。这里我们主要看动态规划算法。

PostgreSQL会首先将解析树转换成另外一种内部数据结构，叫做路径。会自下而上的生成整个查询块的路径。

首先会生成基表扫描的路径。会在生基表描路径的时候，为基表挑选一种最佳的扫描方式，这种方式参考了基表的选择率。一般而言，基表扫描有顺序扫描和索引扫描的方式。优化器会计算顺序扫描的代价，以及利用表上每一个索引扫描的代价。从中挑选一个代价最小的方式作为该表的扫描路径。

如果查询中有Join，则会使用动态规划算法生成Join的路径。会先生成两个表Join的路径，然后是三个表、四个表……直到生成所有表的Join路径。生成两个表Join路径时，会用到基表扫描的路径，同时考虑了表的Join顺序和Join方式（Hash Join、Sort Merge Join或Nest Loop Join），然后保留代价最优的路径供后续路径生成使用。在生成三个表Join路径时，会使用到基表扫描路径和两个表Join路径，层层向上复用，生成更高层Join路径时不需要重复计算底层路径的代价。

在早期的PostgreSQL中，物理优化仅考虑Join顺序和Join路径生成，在最新版本中，将聚集操作也纳入到物理优化之中，会生成聚集路径。

生成完路径后，优化器根据路径生成相应的物理执行计划，一些与执行相关的信息被加入到执行计划中。一些对目标列的处理、窗口函数、聚集操作、排序操作等也被添加到物理执行计划上，以及最后对物理执行计划进行整理。

### Cascades框架

Cascades框架是Volcano框架的面相对象实现，是一种自顶向下的转换型的框架。他主要有两个核心组件组成：MEMO数据结构和优化任务。MEMO数据结构用来保存已搜索的空间数据，优化任务用来引导搜索策略。

#### MEMO数据结构

MEMO数据结构由两部分组成：Groups和GroupExpressions。Groups表示所有等价的算子的集合。GroupExpressions是Groups中的一个算子。

### PostgreSQL优化器 VS Orca

PostgreSQL优化器的流程是自底向上的，先生成基表的访问路径，再层层向上升成最终的执行计划。在层层向上的过程中，挑选每一步的局部最优解，后一步利用前面步骤的结果进行算子的选择。在生成每一层最优解的过程中，并不考虑最终需要的物理属性。最终生成的执行计划并不一定是全局最优的，因为全局最优的计划的分支不一定是局部最优的。

Orca流程是自顶向下的。

PostgreSQL优化器遵循一整套较为死板的工作流，它的顺序不能够被改变，所以对其优化器的更改和扩展比较困难。在实际开发中我们经常发现，对某一个小点的更改会影响流程前后一系列的逻辑，而这样的相互影响有时候是致命的。受困于紧耦合的工作流，我们不得不在梳理前后逻辑和测试模块间交互上花大功夫，有时候是事倍功半的。

Cascades将搜索策略和转换规则分离。开发者可以通过实现一些声明规则达到优化目的，实现这些规则时开发者并不需要对搜索策略进行修改，这样在开发的过程中只需关注转换规则实现，而不用在上下文逻辑和模块间交互上花太多的功夫。

### 一些High Level的点
