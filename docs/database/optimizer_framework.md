

## 概述

在数据库系统中，优化器的作用是为输入的查询语句寻找一个代价最低的，正确的执行计划。但是这是一个NP-hard问题。没有任何一个优化器能够找到一个真正最优的计划，他们采用一些估算的方法猜测计划的执行代价，并且使用一些启发式规则限制搜索的空间。

SQL语句被解析器解析并绑定符号后形成一个逻辑的关系代数表达式。接下来，优化器将这个逻辑的关系代数表达式转换成物理的关系代数表达式，也就是执行计划。这种转换是等价的。所谓等价，是指在他们将产生相同的正确结果。

OLTP的优化器实现相对简单。数据表上通常建有索引，多表之间的连接条件通常在主键和外键之间，所以OLTP优化器可以通过一些简单的启发式规则实现。但是在OLAP数据库中，优化器就要复杂得多。

## 优化器的搜索策略

大体上说，优化器的搜索策略有五种实现方式，分别是：

- 启发式
- 启发式 + 基于代价的Join顺序选择
- 随机算法
- 分层搜索
- 整体搜索

### 启发式

早期的INGRES和Oracle采用的是启发式搜索策略。启发式搜索策略将选择和投影尽量pushdown，将选择利率低的条件先做，Join顺序的选择也是基于选择率的。

启发式的搜索策略首先对语句进行分解，将语句拆分成单表的查询。遇到Join语句时，将Join中的某一个表的所有行取出，获取其Join条件中的列，并在原语句中转换成常量，也就将Join语句换成了带条件的单表查询。往往一条语句要被拆分成数十条语句进行处理。

优点：

- 实现和调试较为简单
- 简单语句运行较快

缺点：

- 难于处理具有复杂的依赖关系的语句

### 启发式 + 基于代价的Join顺序选择

System R、早期的DB2和大多数开源数据库采用这种方法。这是最早的基于代价的优化器实现方式。整体来说是一个Bottom-up的流程。启发式 + 基于代价的Join顺序选择策略是面向Block的，针对每一个Block做各种优化和执行计划生成。

它主要分为两个阶段：

1. 使用一些规则进行初始的优化
2. 使用动态规划算法对Join顺序进行选择

在使用动态规划算法生成路径时，首先，为每一个表生成其访问路径（比如顺序扫描或者索引扫描）。其次，枚举所有可能的Join顺序方案。最后，挑选代价最低的Join顺序，输出执行计划。

System R在生成Join顺序时，采用的是Left-deep树，这可以缩小搜索空间。PostgreSQL并不局限于Left-deep树，它采用了更大的搜索树空间。

优点：

- 受控的搜索空间中可以找到一个相对不错的执行计划

缺点：

- Left-deep树并不一定最优
- 局部最优并不一定使最终的执行计划最优
- 在代价模型中难于考虑一些物理属性，比如数据的排序

### 随机算法

Postgres的遗传算法属于这个分类。首先采用启发式方法生成一个执行计划，然后执行计划在解决方案空间中进行随机的变换，直到其代价满足一个阈值或搜索的时间超过预定的时间。

优点：

- 在解决方案空间中随机的变换可以避免局部最优解
- 无需大量内存保存子执行计划

缺点：

- DBA和用户无法判断为什么DBMS选择这样的执行计划
- 需要额外的工作以确保执行计划的稳定
- 需要实现正确的的转换规则

### 分层搜索

DB2采用这种策略。首先使用查询重写技术对逻辑表达式进行重写，这一步是不考虑代价的。然后然后进行基于代价将逻辑表达式转换为物理执行计划。

### 整体搜索

Volcano和Cascades属于这种搜索策略。他将逻辑表达式到逻辑表达式的转换以及逻辑表达式到物理执行计划的转换整合在了一起。通过一系列的转换规则完成查询语句的优化。它的搜索流程是Top-down的。它是目标驱动的，根据最终的目标一步一步生成最终的执行计划。

在变换的过程中，如果生成的计划偏离了目标（比如不满足排序要求），将对该分支进行剪枝。此外，如果发现某分支的代价大于已生成的分支，也会对这个分支进行剪枝。

优点：

- 具有更好的扩展性
- 通过声明的方式添加转换规则
- 通过一种数据结构，减少冗余的计算

缺点：

- 需要在优化前将所有的等价类展开，并生成所有的物理算子

## 一些High Level的点
