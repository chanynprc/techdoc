## 索引结构

### 索引结构基础

**索引**：以一个或多个字段的值为输入并能快速地找出具有该值得记录。

#### 稠密索引

**稠密索引**：数据文件中的每个记录在索引文件中都设有一个索引项。

如果记录是排好序的，可以在记录上建立稠密索引。索引块中存放记录的键以及指向记录本身的指针。

稠密索引的优点有：

1. 索引块数量通常比数据块数量少
2. 由于键被排序，可使用二分查找法来查找某个键，若有n个索引块，只需要查找$log_2n$个块
3. 索引文件可能足够小，以至于可能常驻主存缓冲区，从而查找某个键不需要IO操作

#### 稀疏索引

**稀疏索引**：数据文件中只有一些记录在索引文件中表示出来，通常为每个数据块在索引文件中设一个索引项。

只有数据文件是按照某个查找键排序时，在该查找键上建立的稀疏索引才能被使用。索引块中存放各数据块第一个记录的键值及数据块的地址指针。

在查找某条键值为K的记录时，先查找键值不大于K的索引项，然后根据指针找到对应的数据块，再在数据块上查找相应的记录。

#### 多级索引

**多级索引**：在某些情况下，通过在索引上再建立索引，能够使单层索引的使用更为有效。B树是一种多级索引。

#### 辅助索引

**辅助索引**：建立在非主键或者未排序的列上的索引，指向存放当前记录的地址，该存放位置由建立在其他某个字段上的主索引确定。

- 辅助索引总是稠密的
- 为了减少辅助索引的空间浪费，可以为辅助索引建立中间层（桶），相同键值的记录在数据文件中的地址在桶中被连续存储。在索引文件中相同键值的记录只有一条，记录该键值和桶中该键值对应位置的地址。由于索引文件对相同键值的记录只记录一条，且桶中不需要记录键值，可以减少重复值较多场景的空间浪费
- 可以利用辅助索引的中间层，加速一些有多个条件的查询。这些查询条件上若都有可用的辅助索引，可以在主存中将各索引中间层（桶）中指针集合求交集来找到满足所有条件的指针，然后再去数据文件中查找对应记录，可以减少读取数据文件的IO开销

#### 倒排索引

**倒排索引**：在文档检索中，为方便按关键字集高效检索文档，对文档中可能出现的词建立一种关系描述，在该描述关系上建立的一种特殊索引称为倒排索引。

一个文档被看成是关系Doc的一个元组，关系Doc有很多属性，每个属性对应于文档中可能出现的一个词，属性是Bool型的，表明该词是否在该文档中出现，因此，这个关系的模式可被看成：

```
Doc (hasDoc, hasCat, ... )
```

在建立索引时，并不是每个属性建立一个单独的索引，而是吧所有索引合成一个，使用中间层（桶）来提高空间利用率。文档的倒排索引包含：

- 倒排索引，包含词-桶地址对
- 桶，包含指向文档的指针，也可以包含词位置、数量等信息。在桶中，包含同一个词的文档的指针被排在一起，如果一个文档中有多个词，那么在桶中会出现多次
- 文档

在建立倒排索引前，有必要对文档进行预处理，比如抽取词干和删除无用词的处理。

在查找时，当查找关键词有多个时，可以使用指针求交的方式对查询进行加速。

### B树

#### B树的结构

B树把它的存储块组织成一颗平衡树，能够自动地保持与数据文件大小相适应的索引层次。

- 每个B树有一个参数n，描述了B树节点的布局。每个节点存放了n个查找键和n+1个指针。因尽可能一个存储块存放一个B树节点，在每个存储块能存放n个查找键和n+1个指针的前提下，n取得尽可能大
- 叶节点的键是数据文件中键，以排好序的方式分布在叶节点中，至少有$\lfloor (n+1)/2 \rfloor$个被使用
- 叶节点的前n个指针指向数据记录（若无对应键，则为空）。叶节点的最后一个指针指向下一个叶节点
- 内层节点的键用于标识下层节点记录的范围，以排好序的方式分布在内层节点中，至少有$n/2$个被使用
- 内层节点的指针都被用来指向下层的节点，至少有$\lceil (n+1)/2 \rceil$个被使用。若有m个键被使用，设为$K_1$，$K_2$，……，$K_{m-1}$，则第1个指针指向下层一个节点，所有键值小于$K_1$的记录可从这一节点为祖先节点的叶节点中找到，第2个指针指向下层的另一个节点，所有键值大于等于$K_1$并小于$K_2$的记录可以从这一节点为祖先节点的叶节点中找到，依此类推
- 根节点类似于内层节点，但其键至少有1个被使用

若B树允许叶节点中的查找键有重复值出现，则需对上述规则进行一定的调整。内层节点若有m个键被使用，设为$K_1$，$K_2$，……，$K_{m-1}$，那么$K_i$将是从第$i+1$个指针所能访问的子树中出现的最小新值（在树的第$i+1$个指针指向的子树以左没有出现过$K_i$）。如果子树的键值都一样，且都不是新的，那么此时$K_i$应被置空。此时，若查找小于$K_{i+1}$的键，只需去第$i$个指针指向的子树的最左叶节点查找即可，若没有找到，不必继续查找后续叶节点（没有新值）。

#### B树的查找

假设要查找键值为K的记录，且B树为没有重复键的稠密索引。

- 结束条件：当前处于叶节点上，按照其键值进行查找，若第i个键值为K，则可通过第i个指针找到相应记录
- 归纳：当前处于内层节点或根节点上，按照内部节点结构规则，若$K_i \leq K < K_{i+1}$，则可通过第i+1个指针指向的子节点继续查找

若要进行范围查找，则先找到范围的下界键值所在的叶节点，然后向后遍历，直到找到上界键值。如果当前叶节点遍历完还没有超越上界键值，则继续遍历下一个叶节点。对于下界是负无穷的情况，则先找到第一个叶节点。对于上界是正无穷的情况，则一直遍历完下界键值所在叶节点后的所有叶节点。

#### B树的插入

- 首先查找要插入的键值，找到合适的叶节点
- 如果叶节点中有空闲空间，直接把键插入这个叶节点，并设置指向记录的指针
- 如果叶节点中没有空闲空间，需要将此叶节点分裂成两个节点，并把新键放入其中一个，使得这两个新的叶节点中键-指针数量满足B树的结构要求（有一半或刚好超过一半的键）
- 某一层分裂节点，在上一层看来就是要插入一个新的键-指针对（键是分裂后多出来的中间位置的键，指针是指向这个新添加节点的指针），可以递归使用如下策略：若有空间，则插入，若无空间，则分裂，并继续递归
- 若根节点中无空闲空间，则需要将根节点分裂成两个节点，并在根节点上面，添加一个新的根节点

若B数的参数n=3，则每个节点有3个键和4个指针的空间。若原键值为10、20、30，添加的键值为15，则新的键值为10、15、20、30，需要将该节点分裂成（10、15）和（30），并将20作为新键值向上递归添加。添加15后，其指针个数从4个变成5个，第1个节点分得3个指针，第2个节点分得2个指针，第2个节点（新）的指针将和键值20一起向上递归添加。

#### B树的删除

- 查找要删除的键
- 若在叶节点中删除找到的键及对应的指针后，剩余的键-指针数目还满足节点要求，则可直接删除
- 若在叶节点中删除找到的键及对应的指针后，剩余的键-指针数目少于要求的最小数目，那么需要进行以下两个操作之一：（1）相邻的兄弟节点中有一个的键-指针对超过最小数据，需要从兄弟节点借一个键-指针对到当前节点，并保持顺序，它们的父节点需要调整以反映新的情况。（2）相邻的兄弟节点中没有一个能提供键值给当前节点，则合并当前节点和一个兄弟节点，并调整其父节点（删除父节点的一个键-指针对，并递归删除键的过程）。

#### B树的效率

### 散列表

### 位图索引

### 说明及引用

（本章内容为《数据库系统实现》（第二版）《索引结构》一章的读书笔记，仅为学习目的，如有侵权，请与笔者联系，[http://www.chenyineng.info/techdoc](http://www.chenyineng.info/techdoc)）

[1] 《数据库系统实现》第二版 
